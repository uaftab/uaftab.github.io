---
layout: post
title: Getting off the ground with C
---

![placeholder](http://weknowmemes.com/generator/uploads/generated/g1362678263447948274.jpg)


For every program there is a `main` function which is the entry point for the program when it is executed. All of the statments in this `main` function are executed sequentially in the order written.

Lets run something first then discuss what it does. The following code can also be used as boilerplate code. 

### Code
{% highlight c %}
/* 
   Boilerplate Code
   Author - UA @uaftab.com
*/
// Comments in C/C++
#include <stdio.h>
int main()
{
    printf( "I am alive!  Beware.\n" );
    getchar();
    return 0;
}
{% endhighlight %}

Copy the code into a new project. 

Hit the Compile and Execute Button.

![placeholder](http://imgs.xkcd.com/comics/compiling.png)

Lets take a look at the elements of our program

The `#include` is called a pre-processor directive. 

Just a fancy way of saying that it tells the compiler to include the code from the specificed file into our program. 

This allows us to use to access methods, functions from different files and libraries that we may want to use. Also we can break up our program into multiple files for better code orgranization and readability. We will take a look later in this tutorial on how to use multiple files. 

`#include<stdio.h>` allows us access to input output functions (get it ? stdANDARD iNPUT oUTPUT) like `printf()` and `getchar()` among others. A list of all the functions is available [here] (http://www.cplusplus.com/reference/cstdio/) 

The next important line is `int main()` this is the decleration for the main function i.e. the entry point for the program. This line tells the compiler that there is a function named main, and that the function returns an integer, hence int. The "curly braces" ({ and }) signal the beginning and end of functions and other code blocks. 

On a side note if you are using C++ then you can also use `void main()` eliminating the need to return an exit code on exit. 

The `printf()` function is a way to display text on the screen. It will display what is in the quotes literall as-is on the screen ; well most of the time. [Heres](http://www.cplusplus.com/reference/cstdio/printf/) a cheatsheet for formatting the output using printf

`getchar()` function is used to input a **single** character from the keyboard. Its return type is a `char` which can be stored in a variable. 

`getch()` also performs the same function but you need to add `#include<conio.h>`

`kbhit()` is also another function that you will see in the examples provided, it waits for an input event, but this function is not a part of C itself it is a part of the compiler so it may not be avaliable on every system an example for it can be found [here](https://github.com/uaftab/MECH-663-472-C-Examples/blob/master/kbhit.cpp)

The next line is `return 0`. When it reaches this statment it exits the program, in the start we defined `int` as the return type for the `main` function. Here `0` is the called the exit code for the program. There can be multiple exit points in your prgoram and it can exit with different codes to indicate exit state. 

![placeholder](http://hugelolcdn.com/i700/218314.jpg)


##printf() Examples
{% highlight c %}
/* printf example */
#include <stdio.h>

int main()
{
   printf ("Characters: %c %c \n", 'a', 65);
   printf ("Decimals: %d %ld\n", 1977, 650000L);
   printf ("Preceding with blanks: %10d \n", 1977);
   printf ("Preceding with zeros: %010d \n", 1977);
   printf ("Some different radices: %d %x %o %#x %#o \n", 100, 100, 100, 100, 100);
   printf ("floats: %4.2f %+.0e %E \n", 3.1416, 3.1416, 3.1416);
   printf ("Width trick: %*d \n", 5, 10);
   printf ("%s \n", "A string");
   return 0;
}
{% endhighlight %}


{% highlight c %}
/*
First step in C programming
Amir Baniamerian, Concordia - March 2015
*/
{% endhighlight %}

In this tutorial we briefly review variables, pointers and functions in C.
# Variables and Pointers
Variables can be categorized in certain subgroups
* int, double, float, char
* Constant vs Variable
* Global vs Local
* Pinters
* Array
* Struct

## Types of variable

In order to use a variable, it necessary to first define the type of the variable:
{% endhighlight %} C++ 
#include<math.h>
main(){
    int var1;
    int var2, var3 = 0; // define variable with initial value
    double var4;
}
{% endhighlight %}
## Constant vs Variable
For some constant values we use constant to
1. Make sure that they are not changed by mistake.
2. If the value is changed, it affect all the program.

#####Example:
{% endhighlight %}C
    #define c1 = 9.8 // note that it is defined before main()
    main(){
        int a = 1;
        double b;
        b = a*c1;
    }
{% endhighlight %}

## Global Vs Local
Variables can be defined global or local. Global variables are know in all files and functions, whereas local variables are only known in the corresponding function-See also the Function Section.

##### Example
{% highlight c %}
double gVar1 = 100.0;    // define a new global variable with initial value
extern flaot gVar2;      // use a global variable defined in another file (that is inculded)
main(){
    int lVar;            // define a local variable
}
{% endhighlight %}
Note that unlike constant variables can be changed in the program.

## Pointers
When we write `c = a+b;`, we are indeed working with the variable names `a,b,c`. Another way (that is more flexible) to manipulate variables is to work with pointers. Pointers are the variables that contains _physical address_ of the other variables. The following example shows how a pointer is defined and used
##### Example
{% endhighlight %} C++
main(){
    int var = 1;        // define a variable
    int *pVar;          // define a poniter that can save the address of a int variable
    pVar = &var;        // put the address of var in pVar
    *pVar = *pVar+1;    // add 1 to the value of var
    pVar = pVar + 1;    // pVar does not points to var any more (points to the next int)
}
{% endhighlight %}
It is very important to note that to change the value, we need to use `*pVar` instead of `pVar`, otherwise pVar would point to another location. Pointers are crucial when we are working with functions and arrays.

## Array
Array is a vector or a matrix of variable (for example an image is save in a matrix). 
##### Exampel
{% highlight c %}
main(){
    int a;              // a single intiger 
    int ar[10];         // 1D integer array
    ar[0] = 1;          // first element is avaialble by ar[0] instead of ar[1] (ar[1] is the second one)
}
{% endhighlight %}
We can defined various types of arrays as follows:
{% highlight c %}
main(){
    int ar1D[10];       // 1d integer array
    int ar2D[10][20];   // 2D integer array
    ar2D[0][0] = 1;     // accessing to the elements
    ar2D[0][1] = 2;     
}
{% endhighlight %} 
### Array vs pointers
To access an array, we usually work with pointers. Consider the following example
##### Example
{% highlight c %}
main(){
    int ar[10], *pAr;
    pAr = &ar;
    ar[0] = 1;      // same as *pAr = 1;
    ar[1] = 2;      // same as *(pAr+1) = 2
}
{% endhighlight %}
### Struct
To capsule related data in a single variable, we use struct. that is defined as follows:
{% highlight c %}
#include<stdio.h>
#include<string.h>              // for string manipulation
struct strExm{
    char name[20];              // these are the fields
    int value;
};                              // note we need this semicolon

 main(){
    struct strExm a;                    // define a as a strExm
    strcpy(a.name, "C Programmer");    // strcpy copy a string to another one
    a.value = 20;                       // note how we can access to the fields
    printf("%s:%d", a.name, a.value);
}
{% endhighlight %}

# Functions
Generally a function is defined by its prototype. The prototype of the function is used to _declare_ a function. Generally, a prototype has three parts, namely: name, input and output arguments. For example:
{% highlight c %}
int exmFunc(double inVar1, flaot *pVar2);       // decleration a function
{% endhighlight %}

In the above example, we _declare_ the function `exmFunc` where its output is an integer, and it has two inputs; `inVar1` that is double and `pVar` which is a pointer to floats. A functions can be declared in the main program or saved in a individual header file. For instance, cosider the following header file that is the `vision.h` file.

{% highlight c %}
    int scale(image *a, image *b);
    int invert(image *a, image *b);
    int convolution(image *a, image *b, int *k, double s);
    int lowpass_filter(image *a, image *b);
    int highpass_filter(image *a, image *b);
    int gaussian_filter(image *a, image *b);
    int threshold(image *a, image *b, int tvalue);
    int histogram(image *a, double *hist, int nhist, double *hmin, double *hmax);
    int dialate(image *a, image *b);
    int erode(image *a, image *b);
{% endhighlight %}

Note that in this case, we have a clean list of available functions in a file.

## Declare function in main program
We usually use this type of declaration in this course, where we declare and define (what it is doing) function in the same place. Consider the following example:
{% highlight c %}
#include <stdio.h>
int addFunc(int a, int b)               // declare the fuction
{                                       // define the function
    int c;
    c = a + b;
    return(c);                          // return the value (the type of c must be the same as output of the function)
}
 main()
{
    int resVar;
    resVar = addFunc(2 , 3);
    printf("%d", resVar);
}
{% endhighlight %}

## Variables in the function
Every variable defined in the function is a local variable. therefore, we can have two variable with the same name in function and main program
We usually use this type of declaration in this course, where we declare and define (what it is doing) function in the same place. Consider the following example:

{% highlight c %}
#include <stdio.h>
double addFunc(double a, double b)               // declare the fuction
{                                               // define the function
    int c;
    c = a + b;
    return(c);                         
}
 main()
{
    double a;
    a = addFunc(2 , 3);
    printf("%d", resVar);
}
{% endhighlight %}

## Input argument
One can pass a variable to a function _by value_ or _by reference_. Consider the following example which shows the passing by value. 

{% highlight c %}
#include <stdio.h>
int addFunc(int a, int b)                // pass a and b by value
{                                                // define the function
    int c;
    c = a + b;
    a++;                                         // a = a + 1;
    b--;                                         // b = b - 1;
    return(c);                         
}
 main()
{
    int a, b, c;
    a = 10; b = 2;
    c = addFunc(a , b);
    printf("%d%d%d", a, b, c);                  // a and b do not change
}
{% endhighlight %}

In the following example `a` is passed by reference and `b` by value.

{% highlight c %}
#include <stdio.h>
int addFunc(int *a, int b)                // pass a and b by value
{                                                // define the function
    int c;
    c = *a + b;
    (*a)++;                                         // (*a) = (*a) + 1;
    b--;                                         // b = b - 1;
    return(c);                         
}
 main()
{
    int a, b, c;
    a = 10; b = 2;
    c = addFunc(&a , b);
    printf("%d%d%d", a, b, c);                  // a and b do not change
}
{% endhighlight %}

Note that although the add function has a single output, it changes the values of `a` and `c`.

### Switch Cases
One of powerful flow statement. It makes program more readable and also faster comparing with if-else (provided the number of cases is sufficiently large).
A general format for switch case in C is shown in the following example

{% highlight c %}
#include<stdio.h>
main(){
int a;
a = 1;
switch (a){
    case 1:                     // if a==1
        printf("Hello\n");
        printf("World\n");
        break;                  //note that always put break at the end of each case 
    case 2:                     // if a==2
       printf("Goodbye\n"); 
       break;
    default:                    // otherwise
        printf("Wait\n");
        break;
    }
}
{% endhighlight %}




### Operators in C

In C/C++ like normal logic there are a number of operators each with its own purpose. An exhaustive list can be found [here](http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B)

**Assignment**

`=` is the assignment operator which is simply used to assign values to variables and constants. Here are few examples
{% highlight c %}
double x1,x2,x3,x4;
x1 = 1.0; // assigment to a constant
x1 = x2 = 2.0; // multiple assignment
x3 = x4 = x1*x2; // assignment to an evaluated expression
	
printf("\nx1 = %lf, x2 = %lf, x3 = %lf, x4 = %lf",x1,x2,x3,x4);
{% endhighlight %}

**Arithmetic Operators**

All arithmetic operators addition, subtraction, multiplication, division are available. These operators can be used normaly with numeric data types, however care must be taken for `Char` and `String` types. For those cases the values would be the numeric equivalent of the character from the ascii table. 

{% highlight c %}
	
double r1=1.0, r2=0.1;

printf("\nr1 = %lf, r2 = %lf",r1,r2);
printf("\nr1 + r2 = %lf",r1+r2); // addition
printf("\nr1 - r2 = %lf",r1-r2); // subraction
printf("\nr1 * r2 = %lf",r1*r2); // multiplication
printf("\nr1 / r2 = %lf\n",r1/r2); // division

int i1=7, i2=3;

printf("\ni1 = %d, i2 = %d",i1,i2);
printf("\ni1 / i2 = %d",i1/i2); // division
printf("\ni1 %% i2 = %d\n",i1%i2); // remainder from integer division
{% endhighlight %}


Incerment `++` and Decrement `--` operators perform the operation just like we expect them to but care must be taken as to how they are used for example `i++` known as Postfix Increment and `++i` known as Prefix Increment will give different results. This holds true for decrement operators also. 
{% highlight c %}
	

printf("\nr1 = %lf",r1);
printf("\nr2 = %lf",r2);
//r1++; // increment (same as r1 = r1 + 1)
//r2--; // decrement (same as r2 = r2 - 1)

printf("\nr1++ = %lf",r1++);
printf("\nr2-- = %lf",r2--);

printf("\nr1 = %lf",r1);
printf("\nr2 = %lf",r2);
    
//++r1; // increment (same as r1 = r1 + 1)
//--r2; // decrement (same as r2 = r2 - 1)

printf("\nr1 = %lf",r1);
printf("\nr2 = %lf",r2);
printf("\n++r1 = %lf",++r1);
printf("\n--r2 = %lf",--r2);
printf("\nr1 = %lf",r1);
printf("\nr2 = %lf",r2);


r1+=5; // increment by 5 (same as r1 = r1 + 5)
r2-=5; // decrement by 5 (same as r2 = r2 - 5)
printf("\nr1+=5 = %lf",r1);
printf("\nr2-=5 = %lf",r2);    

{% endhighlight %}

**Comparison Operators -- Equality**

`==` is the Comparison Operator for `is equal to` , result returned is a boolean true or false. `!=` is the equivalent of `is not equal to`
The purpose is to build conditiondals that allow us to make decisions in the program. 
{% highlight c %}

i1 = 7; // true
i2 = 0; // false
printf("\ni1 = %d (true), i2 = %d (false)",i1,i2);

printf("\n(i1 == 7) = %d",i1 == 7); // equality
printf("\n(i1 != 7) = %d",i1 != 7); // inequality
printf("\n(i1 == i2) = %d",i1 == i2);
printf("\n(i1 != i2) = %d\n",i1 != i2);
{% endhighlight %}


**Relational Operators**

All of the usual relational conditionals can be built using e.g. Greater than `num1 > num2`, and can be compunded with the equality and not operator like `num1>=num2` and vice versa for Less than operator `<`

**Caution remember to compare between same data types for 100% deterministic behaviour**

{% highlight c %}
	
printf("\nr1 = %lf, r2 = %lf",r1,r2);
printf("\n(r1 > r2) = %d",r1 > r2); // greater than
printf("\n(r1 < r2) = %d",r1 < r2); // less than
printf("\n(i1 >= 7) = %d",i1 >= 7);   // greater than or equal to
printf("\n(i1 <= 7) = %d",i1 <= 7);   // less than or equal to
{% endhighlight %}

##Flow Statments

So bascially a program is a set of sequential statments that are executed, in order for meaning full use we have flow control statmenents that allow the program to be flexbile and make decision and follow diffrerent execution paths based on conditonal statments. 

**If/else Statment**

To recap some conditionals 
{% highlight c %}
//src : http://www.cprogramming.com/tutorial/c/lesson2.html

>     greater than              5 > 4 is TRUE
<     less than                 4 < 5 is TRUE
>=    greater than or equal     4 >= 4 is TRUE
<=    less than or equal        3 <= 4 is TRUE
==    equal to                  5 == 5 is TRUE
!=    not equal to              5 != 4 is TRUE
{% endhighlight %}

The if statments allow us to test conditionals and alter code flow based on whether the statment is true or not.

{% highlight c %}
int i1=8,i2=0,i3=11;

// if the logical condition is true then execute the program inside the {}
if(i1 == 7) {
	printf("\ni1 == 7");
}

if(i1 > 7) {
	printf("\ni1 > 7");
}

// if i2 is true then execute the first statement in {}, else 
// execute the second statement in {}
if(i2) {
	printf("\ni2 is true");
} 
else {
	printf("\ni2 is not true");		
}
	
// if-else ladder
if(i3 == 8) {
	printf("\ni3 == 8");
} else if (i3 == 9) {
	printf("\ni3 == 9");
} else if (i3 == 10) {
	printf("\ni3 == 10");
} else {
	printf("\ni3 not equal to 8, 9, or 10");
}
{% endhighlight %}

**Conditional Evaluations**
{% highlight c %}
A. !( 1 || 0 )         ANSWER: 0	
B. !( 1 || 1 && 0 )    ANSWER: 0 (AND is evaluated before OR)
C. !( ( 1 || 0 ) && 0 )  ANSWER: 1 (Parenthesis are useful)
{% endhighlight %}

Before going further, you should understand the concept of C's true and false, because it will be necessary when working with loops (the conditions are the same as with if statements)

**While Loop**

The while loop body code keeps executing till the condtional is true

Boilerplate for while loop
{% highlight c %}
while ( condition ) { 
//Code to execute while the condition is true 
} 
{% endhighlight %}

{% highlight c %}
	int i,j;

	// a while loop executes the statment in {} as long as the
	// test condition in () is true
	i = 0;
	while( i<10 && i!=-1 ) {
		printf("\ni = %d",i);		
		i++;
	}
{% endhighlight %}

**For Loop**

For loops are the most useful type. The syntax for a for loop is 
{% highlight c %}
for ( variable initialization; condition; variable update ) {
  
  Code to execute while the condition is true

}
{% endhighlight %}

The variable initialization allows you to either declare a variable and give it a value or give a value to an already existing variable. Second, the condition tells the program that while the conditional expression is true the loop should continue to repeat itself. The variable update section is the easiest way for a for loop to handle changing of the variable. It is possible to do things like x++, x = x + 10, or even x = random ( 5 ), and if you really wanted to, you could call other functions that do nothing to the variable but still have a useful effect on the code. Notice that a semicolon separates each of these sections, that is important. Also note that every single one of the sections may be empty, though the semicolons still have to be there. If the condition is empty, it is evaluated as true and the loop will repeat until something else stops it. 


{% highlight c %}
// a for loop initializes an index variable and increments 
// it each time through the loop.
// the the statment in {} is executed as long as a
// test condition is true.
for( j=2; j<=10 ; j+=2 ) {
	printf("\nj = %d",j);		
}
{% endhighlight %}

**Switch Case Statment**

With just the If statments we have only a binary code flow path one for true and another for false evaluations of the conditional statments. To cater for more cases we have to latch on more `else if` blocks and like that we get a tree. This is a bit slow as it goes and tests all of those conditionals one by one and which ever block fits executes, and is a pain to write. Fear not for we have the switch statment which solves this exact problem. 

{% highlight c %}
int a = 10;
int b = 10;
int c = 20;

switch ( a ) {
case b:
  /* Code */
  break; //<-- REMEMBER TO PUT THIS OTHERWISE IT WILL CASCADE INTO THE NEXT CASE BLOCK
case c:
  /* Code */
  break;
default:
  /* Code */
  break;
}
{% endhighlight %}

The switch statments accepts the variable that its supposed to "switch" on. The Case statment has the values and code block for each case. One thing imporatant to note is the `break` statment. Once a value is matched and it goes to that case block it executes the code in that case block and the `break` statment tells it to exit the switch block, if the `break` statment was not there then the code execution would overflow into the next case block. 

The default block is there to handle if no case value is matched for the switch variable. 

**EXAMPLE**

{% highlight c %}
#include <stdio.h>

void playgame()
{
    printf( "Play game called" );
}
void loadgame()
{
    printf( "Load game called" );
}
void playmultiplayer()
{
    printf( "Play multiplayer game called" );
}
	
int main()
{
    int input;

    printf( "1. Play game\n" );
    printf( "2. Load game\n" );
    printf( "3. Play multiplayer\n" );
    printf( "4. Exit\n" );
    printf( "Selection: " );
    scanf( "%d", &input );
    switch ( input ) {
        case 1:            /* Note the colon, not a semicolon */
            playgame();
            break;
        case 2:          
            loadgame();
            break;
        case 3:         
            playmultiplayer();
            break;
        case 4:        
            printf( "Thanks for playing!\n" );
            break;
        default:            
            printf( "Bad input, quitting!\n" );
            break;
    }
    getchar();

}

{% endhighlight %}


**GOTO Statment**

This happens when you try to use it. 

![placeholder](http://imgs.xkcd.com/comics/goto.png)



### FILE I/O 

File I/O is simple and can be used for logging during program excution to save log data etc. 

**Opening a File**

* Create a `FILE` pointer as `FILE *fp` for handle of file. 
* `fopen()` to open/create a file to write/read from.
* Syntax: `FILE *fopen(const char *filename, const char *mode);`

* File Modes: 
* r  - open for reading
* w  - open for writing (file need not exist)
* a  - open for appending (file need not exist)
* r+ - open for reading and writing, start at beginning
* w+ - open for reading and writing (overwrite file)
* a+ - open for reading and writing (append if file exists)


**Closing a FILE**

When you're done working with a file, you should close it using the function `int fclose(FILE *a_file);`
fclose returns zero if the file is closed successfully. An example of fclose is `fclose(fp);`

###Writing/Reading to a File

To write we have `fprintf(const char *filename, const char *text2file)` similar to `printf()` just with the inclusion of the file pointer. 

To write just a single character you can also use `int fputc( int c, FILE *fp );`

Similarly to read from a file we have `fscanf` and `fgetc`

###Example
{% highlight c %}

	char file_name[] = "output.txt"; // put in the same directory as the project

	int i, input;

	FILE *fp; // declare a file pointer variable
	
	fp = fopen(file_name,"w"); // open a file for output (writing)

	// check for errors
	if(fp == NULL) {
		printf("\nerror opening file");
		exit(1); // terminate program
	}

	for(i=1;i<=10;i++) {
		fprintf(fp,"%d\n",i);
	}

	fclose(fp); // close the file
	// you must close the file before opening it again.

	printf("\npress a key to continue\n");
	getch();

	// fscanf example

	fp = fopen(file_name,"r"); // open a file for input (reading)

	// check for errors
	if(fp == NULL) {
		printf("\nerror opening file"); 
		exit(1);
	}

	for(i=1;i<=10;i++) {
		fscanf(fp,"%d",&input);
		printf("\ninput = %d",input);
	}

	fclose(fp); // close the file
	// you must close the file before opening it again.

	printf("\ndone.\n");
	getch();
	
{% endhighlight %}	

